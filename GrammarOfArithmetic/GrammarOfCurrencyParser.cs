//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.1 C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g 2016-12-08 13:56:45

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


	using System;
	using System.Collections;
    using Currencies;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;

namespace  Generated 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.1")]
[System.CLSCompliant(false)]
public partial class GrammarOfCurrencyParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "CURRENCY", "EXPONENT", "FLOAT", "ID", "NEWLINE", "SEPARATOR", "'('", "')'", "'*'", "'+'", "'-'", "'/'", "':'", "'='", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__10=10;
	public const int T__11=11;
	public const int T__12=12;
	public const int T__13=13;
	public const int T__14=14;
	public const int T__15=15;
	public const int T__16=16;
	public const int T__17=17;
	public const int T__18=18;
	public const int T__19=19;
	public const int CURRENCY=4;
	public const int EXPONENT=5;
	public const int FLOAT=6;
	public const int ID=7;
	public const int NEWLINE=8;
	public const int SEPARATOR=9;

	#if ANTLR_DEBUG
	private static readonly bool[] decisionCanBacktrack =
		new bool[]
		{
			false, // invalid decision
			false, false, false, false, false, false, false, false
		};
	#else
	private static readonly bool[] decisionCanBacktrack = new bool[0];
	#endif
	public GrammarOfCurrencyParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public GrammarOfCurrencyParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return GrammarOfCurrencyParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g"; } }


	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

	#region Rules

	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_calc() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_calc() {}
	// $ANTLR start "calc"
	// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:15:8: public calc returns [string value] : statement ;
	[GrammarRule("calc")]
	public string calc()
	{
		EnterRule_calc();
		EnterRule("calc", 1);
		TraceIn("calc", 1);
	    string value = default(string);


	    string statement1 = default(string);

		try { DebugEnterRule(GrammarFileName, "calc");
		DebugLocation(15, 1);
		try
		{
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:16:2: ( statement )
			DebugEnterAlt(1);
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:16:5: statement
			{
			DebugLocation(16, 5);
			PushFollow(Follow._statement_in_calc52);
			statement1=statement();
			PopFollow();

			DebugLocation(16, 15);
			value = statement1;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("calc", 1);
			LeaveRule("calc", 1);
			LeaveRule_calc();
	    }
	 	DebugLocation(17, 1);
		} finally { DebugExitRule(GrammarFileName, "calc"); }
		return value;

	}
	// $ANTLR end "calc"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_statement() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_statement() {}
	// $ANTLR start "statement"
	// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:19:1: statement returns [string value] : ( expr ( '=' ID | ( '=' )? ) NEWLINE | NEWLINE );
	[GrammarRule("statement")]
	private string statement()
	{
		EnterRule_statement();
		EnterRule("statement", 2);
		TraceIn("statement", 2);
	    string value = default(string);


	    IToken ID3 = default(IToken);
	    Cur expr2 = default(Cur);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(19, 1);
		try
		{
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:20:2: ( expr ( '=' ID | ( '=' )? ) NEWLINE | NEWLINE )
			int alt3=2;
			try { DebugEnterDecision(3, decisionCanBacktrack[3]);
			int LA3_1 = input.LA(1);

			if ((LA3_1==CURRENCY||LA3_1==FLOAT||LA3_1==10||LA3_1==14||LA3_1==18))
			{
				alt3 = 1;
			}
			else if ((LA3_1==NEWLINE))
			{
				alt3 = 2;
			}

			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}

			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:20:4: expr ( '=' ID | ( '=' )? ) NEWLINE
				{
				DebugLocation(20, 4);
				PushFollow(Follow._expr_in_statement68);
				expr2=expr();
				PopFollow();

				DebugLocation(21, 2);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:21:2: ( '=' ID | ( '=' )? )
				int alt2=2;
				try { DebugEnterSubRule(2);
				try { DebugEnterDecision(2, decisionCanBacktrack[2]);
				int LA2_1 = input.LA(1);

				if ((LA2_1==17))
				{
					int LA2_2 = input.LA(2);

					if ((LA2_2==ID))
					{
						alt2 = 1;
					}
					else if ((LA2_2==NEWLINE))
					{
						alt2 = 2;
					}

					else
					{
						NoViableAltException nvae = new NoViableAltException("", 2, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}

				}
				else if ((LA2_1==NEWLINE))
				{
					alt2 = 2;
				}

				else
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}

				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:21:3: '=' ID
					{
					DebugLocation(21, 3);
					Match(input,17,Follow._17_in_statement73); 
					DebugLocation(21, 7);
					ID3=(IToken)Match(input,ID,Follow._ID_in_statement75); 
					DebugLocation(21, 10);
					value = expr2.Convert((ID3!=null?ID3.Text:default(string)));

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:22:4: ( '=' )?
					{
					DebugLocation(22, 4);
					// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:22:4: ( '=' )?
					int alt1=2;
					try { DebugEnterSubRule(1);
					try { DebugEnterDecision(1, decisionCanBacktrack[1]);
					int LA1_1 = input.LA(1);

					if ((LA1_1==17))
					{
						alt1 = 1;
					}
					} finally { DebugExitDecision(1); }
					switch (alt1)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:22:5: '='
						{
						DebugLocation(22, 5);
						Match(input,17,Follow._17_in_statement84); 
						DebugLocation(22, 9);
						    value = " = ";

						}
						break;

					}
					} finally { DebugExitSubRule(1); }

					DebugLocation(22, 28);
					value = expr2.ToString();

					}
					break;

				}
				} finally { DebugExitSubRule(2); }

				DebugLocation(23, 4);
				Match(input,NEWLINE,Follow._NEWLINE_in_statement95); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:24:4: NEWLINE
				{
				DebugLocation(24, 4);
				Match(input,NEWLINE,Follow._NEWLINE_in_statement101); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statement", 2);
			LeaveRule("statement", 2);
			LeaveRule_statement();
	    }
	 	DebugLocation(25, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return value;

	}
	// $ANTLR end "statement"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_expr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_expr() {}
	// $ANTLR start "expr"
	// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:27:1: expr returns [Cur value] : ( '-' me1= multExpression |me1= multExpression ) ( '+' me2= multExpression | '-' me2= multExpression )* ;
	[GrammarRule("expr")]
	private Cur expr()
	{
		EnterRule_expr();
		EnterRule("expr", 3);
		TraceIn("expr", 3);
	    Cur value = default(Cur);


	    Cur me1 = default(Cur);
	    Cur me2 = default(Cur);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(27, 1);
		try
		{
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:28:2: ( ( '-' me1= multExpression |me1= multExpression ) ( '+' me2= multExpression | '-' me2= multExpression )* )
			DebugEnterAlt(1);
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:28:4: ( '-' me1= multExpression |me1= multExpression ) ( '+' me2= multExpression | '-' me2= multExpression )*
			{
			DebugLocation(28, 4);
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:28:4: ( '-' me1= multExpression |me1= multExpression )
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, decisionCanBacktrack[4]);
			int LA4_1 = input.LA(1);

			if ((LA4_1==14))
			{
				alt4 = 1;
			}
			else if ((LA4_1==CURRENCY||LA4_1==FLOAT||LA4_1==10||LA4_1==18))
			{
				alt4 = 2;
			}

			else
			{
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:28:5: '-' me1= multExpression
				{
				DebugLocation(28, 5);
				Match(input,14,Follow._14_in_expr118); 
				DebugLocation(28, 11);
				PushFollow(Follow._multExpression_in_expr121);
				me1=multExpression();
				PopFollow();

				DebugLocation(28, 27);
				value -= me1;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:29:5: me1= multExpression
				{
				DebugLocation(29, 8);
				PushFollow(Follow._multExpression_in_expr132);
				me1=multExpression();
				PopFollow();

				DebugLocation(29, 24);
				value = me1;

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(30, 2);
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:30:2: ( '+' me2= multExpression | '-' me2= multExpression )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=3;
				try { DebugEnterDecision(5, decisionCanBacktrack[5]);
				int LA5_1 = input.LA(1);

				if ((LA5_1==13))
				{
					alt5 = 1;
				}
				else if ((LA5_1==14))
				{
					alt5 = 2;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:30:3: '+' me2= multExpression
					{
					DebugLocation(30, 3);
					Match(input,13,Follow._13_in_expr139); 
					DebugLocation(30, 10);
					PushFollow(Follow._multExpression_in_expr143);
					me2=multExpression();
					PopFollow();

					DebugLocation(30, 26);
					value += me2;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:31:3: '-' me2= multExpression
					{
					DebugLocation(31, 3);
					Match(input,14,Follow._14_in_expr149); 
					DebugLocation(31, 10);
					PushFollow(Follow._multExpression_in_expr153);
					me2=multExpression();
					PopFollow();

					DebugLocation(31, 26);
					value -= me2;

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expr", 3);
			LeaveRule("expr", 3);
			LeaveRule_expr();
	    }
	 	DebugLocation(32, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return value;

	}
	// $ANTLR end "expr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_multExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_multExpression() {}
	// $ANTLR start "multExpression"
	// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:34:1: multExpression returns [Cur value] : a1= atom ( '*' a2= atom | ( '/' | ':' ) a2= atom )* ;
	[GrammarRule("multExpression")]
	private Cur multExpression()
	{
		EnterRule_multExpression();
		EnterRule("multExpression", 4);
		TraceIn("multExpression", 4);
	    Cur value = default(Cur);


	    Cur a1 = default(Cur);
	    Cur a2 = default(Cur);

		try { DebugEnterRule(GrammarFileName, "multExpression");
		DebugLocation(34, 1);
		try
		{
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:35:2: (a1= atom ( '*' a2= atom | ( '/' | ':' ) a2= atom )* )
			DebugEnterAlt(1);
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:35:4: a1= atom ( '*' a2= atom | ( '/' | ':' ) a2= atom )*
			{
			DebugLocation(35, 6);
			PushFollow(Follow._atom_in_multExpression173);
			a1=atom();
			PopFollow();

			DebugLocation(35, 12);
			value = a1;
			DebugLocation(36, 2);
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:36:2: ( '*' a2= atom | ( '/' | ':' ) a2= atom )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=3;
				try { DebugEnterDecision(6, decisionCanBacktrack[6]);
				int LA6_1 = input.LA(1);

				if ((LA6_1==12))
				{
					alt6 = 1;
				}
				else if (((LA6_1>=15 && LA6_1<=16)))
				{
					alt6 = 2;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:36:3: '*' a2= atom
					{
					DebugLocation(36, 3);
					Match(input,12,Follow._12_in_multExpression179); 
					DebugLocation(36, 9);
					PushFollow(Follow._atom_in_multExpression183);
					a2=atom();
					PopFollow();

					DebugLocation(36, 15);
					value *= a2;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:37:4: ( '/' | ':' ) a2= atom
					{
					DebugLocation(37, 4);
					if ((input.LA(1)>=15 && input.LA(1)<=16))
					{
						input.Consume();
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(37, 16);
					PushFollow(Follow._atom_in_multExpression198);
					a2=atom();
					PopFollow();

					DebugLocation(37, 22);
					value /= a2;

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("multExpression", 4);
			LeaveRule("multExpression", 4);
			LeaveRule_multExpression();
	    }
	 	DebugLocation(39, 1);
		} finally { DebugExitRule(GrammarFileName, "multExpression"); }
		return value;

	}
	// $ANTLR end "multExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_atom() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_atom() {}
	// $ANTLR start "atom"
	// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:41:1: atom returns [Cur value] : ( CURRENCY | FLOAT | ( '(' a1= expr ')' | '{' a1= expr '}' ) );
	[GrammarRule("atom")]
	private Cur atom()
	{
		EnterRule_atom();
		EnterRule("atom", 5);
		TraceIn("atom", 5);
	    Cur value = default(Cur);


	    IToken CURRENCY4 = default(IToken);
	    IToken FLOAT5 = default(IToken);
	    Cur a1 = default(Cur);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(41, 1);
		try
		{
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:42:2: ( CURRENCY | FLOAT | ( '(' a1= expr ')' | '{' a1= expr '}' ) )
			int alt8=3;
			try { DebugEnterDecision(8, decisionCanBacktrack[8]);
			switch (input.LA(1))
			{
			case CURRENCY:
				{
				alt8 = 1;
				}
				break;
			case FLOAT:
				{
				alt8 = 2;
				}
				break;
			case 10:
			case 18:
				{
				alt8 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 8, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:42:4: CURRENCY
				{
				DebugLocation(42, 4);
				CURRENCY4=(IToken)Match(input,CURRENCY,Follow._CURRENCY_in_atom218); 
				DebugLocation(42, 13);
				value = new Cur((CURRENCY4!=null?CURRENCY4.Text:default(string)));

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:43:4: FLOAT
				{
				DebugLocation(43, 4);
				FLOAT5=(IToken)Match(input,FLOAT,Follow._FLOAT_in_atom225); 
				DebugLocation(43, 10);
				value = new Cur(double.Parse((FLOAT5!=null?FLOAT5.Text:default(string))));

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:44:4: ( '(' a1= expr ')' | '{' a1= expr '}' )
				{
				DebugLocation(44, 4);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:44:4: ( '(' a1= expr ')' | '{' a1= expr '}' )
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, decisionCanBacktrack[7]);
				int LA7_1 = input.LA(1);

				if ((LA7_1==10))
				{
					alt7 = 1;
				}
				else if ((LA7_1==18))
				{
					alt7 = 2;
				}

				else
				{
					NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}

				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:44:5: '(' a1= expr ')'
					{
					DebugLocation(44, 5);
					Match(input,10,Follow._10_in_atom233); 
					DebugLocation(44, 12);
					PushFollow(Follow._expr_in_atom239);
					a1=expr();
					PopFollow();

					DebugLocation(44, 19);
					Match(input,11,Follow._11_in_atom241); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\GrammarOfCurrency.g:44:24: '{' a1= expr '}'
					{
					DebugLocation(44, 24);
					Match(input,18,Follow._18_in_atom244); 
					DebugLocation(44, 31);
					PushFollow(Follow._expr_in_atom250);
					a1=expr();
					PopFollow();

					DebugLocation(44, 38);
					Match(input,19,Follow._19_in_atom252); 

					}
					break;

				}
				} finally { DebugExitSubRule(7); }

				DebugLocation(45, 3);
				value = a1;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 5);
			LeaveRule("atom", 5);
			LeaveRule_atom();
	    }
	 	DebugLocation(46, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return value;

	}
	// $ANTLR end "atom"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _statement_in_calc52 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_statement68 = new BitSet(new ulong[]{0x20100UL});
		public static readonly BitSet _17_in_statement73 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _ID_in_statement75 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _17_in_statement84 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _NEWLINE_in_statement95 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEWLINE_in_statement101 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _14_in_expr118 = new BitSet(new ulong[]{0x40450UL});
		public static readonly BitSet _multExpression_in_expr121 = new BitSet(new ulong[]{0x6002UL});
		public static readonly BitSet _multExpression_in_expr132 = new BitSet(new ulong[]{0x6002UL});
		public static readonly BitSet _13_in_expr139 = new BitSet(new ulong[]{0x40450UL});
		public static readonly BitSet _multExpression_in_expr143 = new BitSet(new ulong[]{0x6002UL});
		public static readonly BitSet _14_in_expr149 = new BitSet(new ulong[]{0x40450UL});
		public static readonly BitSet _multExpression_in_expr153 = new BitSet(new ulong[]{0x6002UL});
		public static readonly BitSet _atom_in_multExpression173 = new BitSet(new ulong[]{0x19002UL});
		public static readonly BitSet _12_in_multExpression179 = new BitSet(new ulong[]{0x40450UL});
		public static readonly BitSet _atom_in_multExpression183 = new BitSet(new ulong[]{0x19002UL});
		public static readonly BitSet _set_in_multExpression190 = new BitSet(new ulong[]{0x40450UL});
		public static readonly BitSet _atom_in_multExpression198 = new BitSet(new ulong[]{0x19002UL});
		public static readonly BitSet _CURRENCY_in_atom218 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_atom225 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _10_in_atom233 = new BitSet(new ulong[]{0x44450UL});
		public static readonly BitSet _expr_in_atom239 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _11_in_atom241 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _18_in_atom244 = new BitSet(new ulong[]{0x44450UL});
		public static readonly BitSet _expr_in_atom250 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _19_in_atom252 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  Generated 
