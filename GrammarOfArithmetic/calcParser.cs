//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.1 C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g 2016-12-06 15:13:12

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


	using System;
	using System.Collections;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;

namespace  Generated 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.1")]
[System.CLSCompliant(false)]
public partial class calcParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "EXPONENT", "FLOAT", "ID", "NEWLINE", "SEPARATOR", "'('", "')'", "'*'", "'+'", "'-'", "'/'", "'='", "'['", "']'"
	};
	public const int EOF=-1;
	public const int T__9=9;
	public const int T__10=10;
	public const int T__11=11;
	public const int T__12=12;
	public const int T__13=13;
	public const int T__14=14;
	public const int T__15=15;
	public const int T__16=16;
	public const int T__17=17;
	public const int EXPONENT=4;
	public const int FLOAT=5;
	public const int ID=6;
	public const int NEWLINE=7;
	public const int SEPARATOR=8;

	#if ANTLR_DEBUG
	private static readonly bool[] decisionCanBacktrack =
		new bool[]
		{
			false, // invalid decision
			false, false, false, false, false, false
		};
	#else
	private static readonly bool[] decisionCanBacktrack = new bool[0];
	#endif
	public calcParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public calcParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return calcParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g"; } }


		Hashtable memory = new Hashtable();


	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

	#region Rules

	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_calc() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_calc() {}
	// $ANTLR start "calc"
	// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:17:8: public calc : ( statement )+ ;
	[GrammarRule("calc")]
	public void calc()
	{
		EnterRule_calc();
		EnterRule("calc", 1);
		TraceIn("calc", 1);
		try { DebugEnterRule(GrammarFileName, "calc");
		DebugLocation(17, 1);
		try
		{
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:18:2: ( ( statement )+ )
			DebugEnterAlt(1);
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:18:4: ( statement )+
			{
			DebugLocation(18, 4);
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:18:4: ( statement )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, decisionCanBacktrack[1]);
				int LA1_1 = input.LA(1);

				if (((LA1_1>=FLOAT && LA1_1<=NEWLINE)||LA1_1==9||LA1_1==13||LA1_1==16))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:18:4: statement
					{
					DebugLocation(18, 4);
					PushFollow(Follow._statement_in_calc52);
					statement();
					PopFollow();


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("calc", 1);
			LeaveRule("calc", 1);
			LeaveRule_calc();
	    }
	 	DebugLocation(19, 1);
		} finally { DebugExitRule(GrammarFileName, "calc"); }
		return;

	}
	// $ANTLR end "calc"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_statement() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_statement() {}
	// $ANTLR start "statement"
	// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:21:1: statement : ( expr NEWLINE | ID '=' expr NEWLINE | NEWLINE );
	[GrammarRule("statement")]
	private void statement()
	{
		EnterRule_statement();
		EnterRule("statement", 2);
		TraceIn("statement", 2);
	    IToken ID2 = default(IToken);
	    double expr1 = default(double);
	    double expr3 = default(double);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(21, 1);
		try
		{
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:22:2: ( expr NEWLINE | ID '=' expr NEWLINE | NEWLINE )
			int alt2=3;
			try { DebugEnterDecision(2, decisionCanBacktrack[2]);
			switch (input.LA(1))
			{
			case FLOAT:
			case 9:
			case 13:
			case 16:
				{
				alt2 = 1;
				}
				break;
			case ID:
				{
				int LA2_2 = input.LA(2);

				if ((LA2_2==15))
				{
					alt2 = 2;
				}
				else if ((LA2_2==NEWLINE||(LA2_2>=11 && LA2_2<=14)))
				{
					alt2 = 1;
				}

				else
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}

				}
				break;
			case NEWLINE:
				{
				alt2 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:22:4: expr NEWLINE
				{
				DebugLocation(22, 4);
				PushFollow(Follow._expr_in_statement64);
				expr1=expr();
				PopFollow();

				DebugLocation(22, 9);
				Match(input,NEWLINE,Follow._NEWLINE_in_statement66); 
				DebugLocation(22, 17);
				 Console.WriteLine(expr1); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:23:4: ID '=' expr NEWLINE
				{
				DebugLocation(23, 4);
				ID2=(IToken)Match(input,ID,Follow._ID_in_statement73); 
				DebugLocation(23, 7);
				Match(input,15,Follow._15_in_statement75); 
				DebugLocation(23, 11);
				PushFollow(Follow._expr_in_statement77);
				expr3=expr();
				PopFollow();

				DebugLocation(23, 16);
				Match(input,NEWLINE,Follow._NEWLINE_in_statement79); 
				DebugLocation(23, 24);
				 memory.Add((ID2!=null?ID2.Text:default(string)), expr3); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:24:4: NEWLINE
				{
				DebugLocation(24, 4);
				Match(input,NEWLINE,Follow._NEWLINE_in_statement86); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statement", 2);
			LeaveRule("statement", 2);
			LeaveRule_statement();
	    }
	 	DebugLocation(25, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return;

	}
	// $ANTLR end "statement"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_expr() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_expr() {}
	// $ANTLR start "expr"
	// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:28:1: expr returns [double value] : ( '-' me1= multExpression |me1= multExpression ) ( '+' me2= multExpression | '-' me2= multExpression )* ;
	[GrammarRule("expr")]
	private double expr()
	{
		EnterRule_expr();
		EnterRule("expr", 3);
		TraceIn("expr", 3);
	    double value = default(double);


	    double me1 = default(double);
	    double me2 = default(double);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(28, 1);
		try
		{
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:29:2: ( ( '-' me1= multExpression |me1= multExpression ) ( '+' me2= multExpression | '-' me2= multExpression )* )
			DebugEnterAlt(1);
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:29:4: ( '-' me1= multExpression |me1= multExpression ) ( '+' me2= multExpression | '-' me2= multExpression )*
			{
			DebugLocation(29, 4);
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:29:4: ( '-' me1= multExpression |me1= multExpression )
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, decisionCanBacktrack[3]);
			int LA3_1 = input.LA(1);

			if ((LA3_1==13))
			{
				alt3 = 1;
			}
			else if (((LA3_1>=FLOAT && LA3_1<=ID)||LA3_1==9||LA3_1==16))
			{
				alt3 = 2;
			}

			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}

			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:29:5: '-' me1= multExpression
				{
				DebugLocation(29, 5);
				Match(input,13,Follow._13_in_expr103); 
				DebugLocation(29, 11);
				PushFollow(Follow._multExpression_in_expr106);
				me1=multExpression();
				PopFollow();

				DebugLocation(29, 27);
				value -= me1;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:29:45: me1= multExpression
				{
				DebugLocation(29, 48);
				PushFollow(Follow._multExpression_in_expr113);
				me1=multExpression();
				PopFollow();

				DebugLocation(29, 64);
				value = me1;

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(30, 2);
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:30:2: ( '+' me2= multExpression | '-' me2= multExpression )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=3;
				try { DebugEnterDecision(4, decisionCanBacktrack[4]);
				int LA4_1 = input.LA(1);

				if ((LA4_1==12))
				{
					alt4 = 1;
				}
				else if ((LA4_1==13))
				{
					alt4 = 2;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:30:3: '+' me2= multExpression
					{
					DebugLocation(30, 3);
					Match(input,12,Follow._12_in_expr120); 
					DebugLocation(30, 10);
					PushFollow(Follow._multExpression_in_expr124);
					me2=multExpression();
					PopFollow();

					DebugLocation(30, 26);
					value += me2;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:31:3: '-' me2= multExpression
					{
					DebugLocation(31, 3);
					Match(input,13,Follow._13_in_expr130); 
					DebugLocation(31, 10);
					PushFollow(Follow._multExpression_in_expr134);
					me2=multExpression();
					PopFollow();

					DebugLocation(31, 26);
					value -= me2;

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expr", 3);
			LeaveRule("expr", 3);
			LeaveRule_expr();
	    }
	 	DebugLocation(32, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return value;

	}
	// $ANTLR end "expr"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_multExpression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_multExpression() {}
	// $ANTLR start "multExpression"
	// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:34:1: multExpression returns [double value] : a1= atom ( '*' a2= atom | '/' a2= atom )* ;
	[GrammarRule("multExpression")]
	private double multExpression()
	{
		EnterRule_multExpression();
		EnterRule("multExpression", 4);
		TraceIn("multExpression", 4);
	    double value = default(double);


	    double a1 = default(double);
	    double a2 = default(double);

		try { DebugEnterRule(GrammarFileName, "multExpression");
		DebugLocation(34, 1);
		try
		{
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:35:2: (a1= atom ( '*' a2= atom | '/' a2= atom )* )
			DebugEnterAlt(1);
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:35:4: a1= atom ( '*' a2= atom | '/' a2= atom )*
			{
			DebugLocation(35, 6);
			PushFollow(Follow._atom_in_multExpression154);
			a1=atom();
			PopFollow();

			DebugLocation(35, 12);
			value = a1;
			DebugLocation(36, 2);
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:36:2: ( '*' a2= atom | '/' a2= atom )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=3;
				try { DebugEnterDecision(5, decisionCanBacktrack[5]);
				int LA5_1 = input.LA(1);

				if ((LA5_1==11))
				{
					alt5 = 1;
				}
				else if ((LA5_1==14))
				{
					alt5 = 2;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:36:3: '*' a2= atom
					{
					DebugLocation(36, 3);
					Match(input,11,Follow._11_in_multExpression160); 
					DebugLocation(36, 9);
					PushFollow(Follow._atom_in_multExpression164);
					a2=atom();
					PopFollow();

					DebugLocation(36, 15);
					value *= a2;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:37:3: '/' a2= atom
					{
					DebugLocation(37, 3);
					Match(input,14,Follow._14_in_multExpression170); 
					DebugLocation(37, 9);
					PushFollow(Follow._atom_in_multExpression174);
					a2=atom();
					PopFollow();

					DebugLocation(37, 15);
					value /= a2;

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("multExpression", 4);
			LeaveRule("multExpression", 4);
			LeaveRule_multExpression();
	    }
	 	DebugLocation(38, 1);
		} finally { DebugExitRule(GrammarFileName, "multExpression"); }
		return value;

	}
	// $ANTLR end "multExpression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_atom() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_atom() {}
	// $ANTLR start "atom"
	// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:40:1: atom returns [double value] : ( ID | FLOAT | '(' expr ')' | '[' expr ']' );
	[GrammarRule("atom")]
	private double atom()
	{
		EnterRule_atom();
		EnterRule("atom", 5);
		TraceIn("atom", 5);
	    double value = default(double);


	    IToken ID4 = default(IToken);
	    IToken FLOAT5 = default(IToken);
	    double expr6 = default(double);
	    double expr7 = default(double);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(40, 1);
		try
		{
			// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:41:2: ( ID | FLOAT | '(' expr ')' | '[' expr ']' )
			int alt6=4;
			try { DebugEnterDecision(6, decisionCanBacktrack[6]);
			switch (input.LA(1))
			{
			case ID:
				{
				alt6 = 1;
				}
				break;
			case FLOAT:
				{
				alt6 = 2;
				}
				break;
			case 9:
				{
				alt6 = 3;
				}
				break;
			case 16:
				{
				alt6 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 6, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:41:4: ID
				{
				DebugLocation(41, 4);
				ID4=(IToken)Match(input,ID,Follow._ID_in_atom192); 
				DebugLocation(41, 7);
				value = (double)memory[(ID4!=null?ID4.Text:default(string))];

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:42:4: FLOAT
				{
				DebugLocation(42, 4);
				FLOAT5=(IToken)Match(input,FLOAT,Follow._FLOAT_in_atom199); 
				DebugLocation(42, 10);
				value = double.Parse((FLOAT5!=null?FLOAT5.Text:default(string)));

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:43:4: '(' expr ')'
				{
				DebugLocation(43, 4);
				Match(input,9,Follow._9_in_atom206); 
				DebugLocation(43, 8);
				PushFollow(Follow._expr_in_atom208);
				expr6=expr();
				PopFollow();

				DebugLocation(43, 13);
				Match(input,10,Follow._10_in_atom210); 
				DebugLocation(43, 17);
				value = expr6;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\illus\\OneDrive\\Документы\\Visual Studio 2015\\Projects\\Calculator\\calc.g:44:4: '[' expr ']'
				{
				DebugLocation(44, 4);
				Match(input,16,Follow._16_in_atom217); 
				DebugLocation(44, 8);
				PushFollow(Follow._expr_in_atom219);
				expr7=expr();
				PopFollow();

				DebugLocation(44, 13);
				Match(input,17,Follow._17_in_atom221); 
				DebugLocation(44, 17);
				value = Math.Abs(expr7);

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 5);
			LeaveRule("atom", 5);
			LeaveRule_atom();
	    }
	 	DebugLocation(45, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return value;

	}
	// $ANTLR end "atom"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _statement_in_calc52 = new BitSet(new ulong[]{0x122E2UL});
		public static readonly BitSet _expr_in_statement64 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _NEWLINE_in_statement66 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_statement73 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _15_in_statement75 = new BitSet(new ulong[]{0x12260UL});
		public static readonly BitSet _expr_in_statement77 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _NEWLINE_in_statement79 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEWLINE_in_statement86 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _13_in_expr103 = new BitSet(new ulong[]{0x10260UL});
		public static readonly BitSet _multExpression_in_expr106 = new BitSet(new ulong[]{0x3002UL});
		public static readonly BitSet _multExpression_in_expr113 = new BitSet(new ulong[]{0x3002UL});
		public static readonly BitSet _12_in_expr120 = new BitSet(new ulong[]{0x10260UL});
		public static readonly BitSet _multExpression_in_expr124 = new BitSet(new ulong[]{0x3002UL});
		public static readonly BitSet _13_in_expr130 = new BitSet(new ulong[]{0x10260UL});
		public static readonly BitSet _multExpression_in_expr134 = new BitSet(new ulong[]{0x3002UL});
		public static readonly BitSet _atom_in_multExpression154 = new BitSet(new ulong[]{0x4802UL});
		public static readonly BitSet _11_in_multExpression160 = new BitSet(new ulong[]{0x10260UL});
		public static readonly BitSet _atom_in_multExpression164 = new BitSet(new ulong[]{0x4802UL});
		public static readonly BitSet _14_in_multExpression170 = new BitSet(new ulong[]{0x10260UL});
		public static readonly BitSet _atom_in_multExpression174 = new BitSet(new ulong[]{0x4802UL});
		public static readonly BitSet _ID_in_atom192 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_atom199 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _9_in_atom206 = new BitSet(new ulong[]{0x12260UL});
		public static readonly BitSet _expr_in_atom208 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _10_in_atom210 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _16_in_atom217 = new BitSet(new ulong[]{0x12260UL});
		public static readonly BitSet _expr_in_atom219 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_atom221 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  Generated 
